# [[2618번]](https://www.acmicpc.net/problem/2618) 경찰차

## 해결 방법

DP를 이용하여 해결한다. 각 사건을 경찰차1이 해결하는 경우, 경찰차2가 해결하는 경우로 나누어
둘 중 빠른 방법을 선택한다.

- dp[a][b]는 경찰차1이 a번째 사건이 발생한 위치에 있고 경찰차2가 b번째 사건이 발생한 위치에 있을 때 w개의 사건을 모두 처리하며 경찰차가 이동한 거리의 합의 최소값이다.
- a 또는 b가 0인 경우 초기 위치를 나타낸다.
- dp배열의 초기값을 -1로 설정한다.

---

### 1. DP식(solve 함수) 세우기

- 모든 사건을 해결한 경우에는 0을 반환한다.
- 만약 dp[car1][car2]가 -1이 아닌 경우 이미 최소값을 구한 상태이므로 값을 그대로 반환한다.
- 현재 사건을 1번이 해결하는 경우, 2번이 해결하는 경우를 나누어 둘 중 최소값을 선택한다.
- 1번이 해결하는 경우 solve(num+1, num, car2) + dist1
- 2번이 해결하는 경우 solve(num+1, car1, num) + dist2
- dist는 각 경찰차가 해결하는 경우 이동거리를 나타낸다.

### 2. 각 사건을 해결하는 경찰차 번호 저장

- 위에서 1번과 2번이 해결하는 경우 중 작은 값을 선택하므로 이를 비교할 때 p배열에 어떤 경찰차가 해결하는지 저장한다.
- 1인경우 2번 경찰차가, 0인 경우 1번 경찰차가 해결한 것을 의미한다.

### 3. 정답 구하기

- 먼저, 이동한 거리의 최소값은 solve(1, 0, 0)을 통해 구할 수 있다.
- x = 0, y = 0인 상태에서 시작하여 p값을 통해 어떤 경찰차가 해결하였는지를 출력한다.
- 이후 해결한 경찰차의 위치를 다음 사건위치로 이동시킨다.
- 위를 x, y의 최대 값이 사건의 개수 이상이 될 때 까지 반복한다.

---

## 하면서 얻은 것

- 엄청 많이 틀리고 시간도 많이 썼다.
- 이러한 형태의 DP문제를 생각하는데 어려움을 겪는 것 같다. 비슷한 유형의 문제를 많이 풀어봐야겠다.
- 특히 solve가 주어진 상태에서 마지막 상태까지 가는 비용을 나타내는 풀이를 해야하는 문제에 약한 것 같다.
